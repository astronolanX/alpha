---
// GridFacade.astro - Dynamic modular grid with alignment guides
---

<div class="grid-facade" id="gridFacade">
  <div class="grid-container" id="gridContainer">&nbsp;</div>
  <div class="guides-container" id="guidesContainer">&nbsp;</div>
</div>

<style is:global>
  .grid-facade {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background-color: var(--color-surface);
  }

  .grid-container {
    position: absolute;
    background-color: var(--color-surface);
  }

  .guides-container {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  .grid-block {
    position: absolute;
    background-color: #ffffff;
    cursor: pointer;
    pointer-events: auto;
    z-index: 2;
  }

  .grid-block:hover {
    transform: scale(1.03);
    transition: transform 0.2s ease-out;
  }

  .guide-line {
    position: absolute;
    opacity: 0;
    transition: opacity 0.3s ease-out;
    z-index: 1;
  }

  .guide-line.visible {
    opacity: 1;
  }

  .guide-line.horizontal {
    height: 1px;
    left: 0;
    right: 0;
    background: linear-gradient(90deg,
      transparent 0%,
      var(--color-guide-h) 10%,
      var(--color-guide-h) 90%,
      transparent 100%
    );
  }

  .guide-line.vertical {
    width: 1px;
    top: 0;
    bottom: 0;
    background: linear-gradient(180deg,
      transparent 0%,
      var(--color-guide-h) 10%,
      var(--color-guide-h) 90%,
      transparent 100%
    );
  }
</style>

<script>
  import { animate, stagger } from 'motion';

  const container = document.getElementById('gridContainer')!;
  const guidesContainer = document.getElementById('guidesContainer')!;

  const NUM_BLOCKS = 7;
  const GUTTER = 24;

  interface Block {
    col: number;
    row: number;
    colSpan: number;
    rowSpan: number;
    left: number;
    top: number;
    width: number;
    height: number;
  }

  let blocks: Block[] = [];
  let cols = 12;
  let rows = 12;
  let cellSize = 0;

  function calculateGrid() {
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const targetCellSize = Math.min(vw, vh) < 640 ? 64 : Math.min(vw, vh) < 1024 ? 80 : 96;

    cols = Math.ceil(vw / targetCellSize);
    rows = Math.ceil(vh / targetCellSize);
    cellSize = Math.max(vw / cols, vh / rows);
    cols = Math.ceil(vw / cellSize);
    rows = Math.ceil(vh / cellSize);
  }

  function centerBiasedRandom() {
    return (Math.random() + Math.random()) / 2;
  }

  function generateLayout() {
    blocks = [];
    const occupied: boolean[][] = Array.from({ length: rows }, () => Array(cols).fill(false));

    const colMargin = Math.floor(cols * 0.25);
    const rowMargin = Math.floor(rows * 0.25);

    for (let i = 0; i < NUM_BLOCKS; i++) {
      const block = tryPlaceBlock(occupied, colMargin, cols - colMargin, rowMargin, rows - rowMargin);
      if (block) blocks.push(block);
    }
  }

  function tryPlaceBlock(occupied: boolean[][], minCol: number, maxCol: number, minRow: number, maxRow: number): Block | null {
    for (let attempt = 0; attempt < 100; attempt++) {
      const width = 1 + Math.floor(Math.random() * 3);
      const height = 1 + Math.floor(Math.random() * 3);

      const availableCols = maxCol - minCol - width + 1;
      const availableRows = maxRow - minRow - height + 1;
      if (availableCols <= 0 || availableRows <= 0) continue;

      const col = minCol + Math.floor(centerBiasedRandom() * availableCols);
      const row = minRow + Math.floor(centerBiasedRandom() * availableRows);

      let canPlace = true;
      for (let r = row; r < row + height && canPlace; r++) {
        for (let c = col; c < col + width && canPlace; c++) {
          if (r >= rows || c >= cols || occupied[r][c]) canPlace = false;
        }
      }

      if (canPlace) {
        for (let r = row; r < row + height; r++) {
          for (let c = col; c < col + width; c++) {
            occupied[r][c] = true;
          }
        }
        return {
          col,
          row,
          colSpan: width,
          rowSpan: height,
          left: col * cellSize,
          top: row * cellSize,
          width: width * cellSize,
          height: height * cellSize,
        };
      }
    }
    return null;
  }

  function render() {
    container.style.width = '100vw';
    container.style.height = '100vh';
    container.style.left = '0';
    container.style.top = '0';

    guidesContainer.innerHTML = '';
    const half = GUTTER / 2;

    blocks.forEach((block, index) => {
      const el = document.createElement('div');
      el.className = 'grid-block';
      el.style.left = `${block.left + half}px`;
      el.style.top = `${block.top + half}px`;
      el.style.width = `${block.width - GUTTER}px`;
      el.style.height = `${block.height - GUTTER}px`;
      el.dataset.index = String(index);

      el.addEventListener('click', () => {
        animate(el, { scale: [1, 0.92, 1] }, { duration: 0.25 });
      });

      guidesContainer.appendChild(el);
    });
  }

  function addGuidesForBlock(block: Block) {
    const half = GUTTER / 2;
    const actualLeft = block.left + half;
    const actualTop = block.top + half;
    const actualRight = block.left + block.width - half;
    const actualBottom = block.top + block.height - half;

    const guides = [
      { className: 'guide-line horizontal', style: `top: ${actualTop}px` },
      { className: 'guide-line horizontal', style: `top: ${actualBottom}px` },
      { className: 'guide-line vertical', style: `left: ${actualLeft}px` },
      { className: 'guide-line vertical', style: `left: ${actualRight}px` },
    ];

    guides.forEach(({ className, style }) => {
      const guide = document.createElement('div');
      guide.className = className;
      guide.style.cssText = style;
      guidesContainer.appendChild(guide);
      requestAnimationFrame(() => guide.classList.add('visible'));
    });
  }

  function animateIn() {
    const blockEls = guidesContainer.querySelectorAll('.grid-block');

    animate(
      blockEls,
      { opacity: [0, 1], scale: [0, 1] },
      { duration: 0.5, delay: stagger(0.12), easing: [0.34, 1.56, 0.64, 1] }
    );

    // Add guides after blocks animate in
    blockEls.forEach((_, index) => {
      setTimeout(() => addGuidesForBlock(blocks[index]), 150 + index * 120 + 300);
    });
  }

  function init() {
    calculateGrid();
    generateLayout();
    render();
    animateIn();
  }

  let resizeTimeout: number;

  function onResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      // Regenerate layout entirely for new viewport
      calculateGrid();
      generateLayout();
      render();
      animateIn();
    }, 150);
  }

  init();
  window.addEventListener('resize', onResize);
</script>
